##
# The triggers in this file perform parameterized calculations, saving the results to `scope:result`.
#
# The effect is to clamp down on the AI value when it is inappropriate.
# i.e. this is a strictly negative effect, we use this to calculate how hard we want to stop the AI
#  -> the goal is to prevent the AI overbuilding, since we can't force it to let things downgrade...
##

usu_calculate_building_good_ai_value_profit_adjustment = {
	save_temporary_scope_value_as = {
		name = result
		value = {
			sg:$good$ ?= { # Set the value to the total current production in the state
				#value = state_goods_delta		#used delta initially so the ai value adjustment would drop off quicker in large states, but that approach turns out to have issues
				value = state_goods_production	#for relative production after queued construction
			}
			save_temporary_value_as = local_goods_production
			add = { # Now, we need the production of JUST ONE MORE BUILDING LEVEL
				value = 0
				if = {
					limit = {
						exists = b:$building$
					}
					b:$building$ = {
						add = modifier:goods_output_$good$_add
						multiply = {
							value = modifier:goods_output_$good$_mult
							add = 1
						}
						save_temporary_value_as = good_production_current	# Because we are inside the add - this is just the current building production
						if = {
							limit = {
								level > 0
								occupancy > 0
							}
							divide = occupancy	# Dividing by low occupancy multiplies the anticipated production/level, further countering overshoot
							divide = level
						}
						else = {
							value = $fallback_production$ # Assume goods production of best PM
						}
						save_temporary_value_as = good_production_per_level
						multiply = {
							value = level_after_queued_constructions
							add = 1 # For value of the next level
						}
						save_temporary_value_as = good_production_after_queued
						subtract = scope:good_production_current	# Subtract current building production from level + 1 production
					}
				}
				else = {
					value = $fallback_production$
					save_temporary_value_as = good_production_per_level
				}
			}
			min = 0 # Value at this point needs to be JUST state_goods_production PLUS the production of ONE MORE BUILDING LEVEL
			sg:$good$ ?= {
				divide = {
					value = state_goods_consumption
					min = 1
				}
			}
			save_temporary_value_as = relative_after_queued
			
			# This multiplier should match the AI value of 1 level of goods production at max price
			# in order to cancel out a worst case profit estimate where min price goods are
			# incorectly forcasted to move to max price.
			# `employees_per_level` can not be calculated. Use highest automation pm numbers for best late game results.
			# Approximately: 
			# ```
			# good.base_price * (1 + NEconomy|PRICE_RANGE)
			#    * NAI|PRODUCTION_BUILDING_GOODS_PROFIT_FACTOR
			#    * NAI|PRODUCTION_BUILDING_AUTONOMOUS_INVESTMENT_PROFIT_FACTOR_MULT
			#    * scope:good_production_per_level / employees_per_level
			# ```
		#	multiply = {
		#		value = g:$good$.base_price
		#		multiply = {
		#			value = 1
		#			add = define:NEconomy|PRICE_RANGE
		#		}
		#		multiply = define:NAI|PRODUCTION_BUILDING_GOODS_PROFIT_FACTOR
		#		multiply = define:NAI|PRODUCTION_BUILDING_AUTONOMOUS_INVESTMENT_PROFIT_FACTOR_MULT
		#		multiply = scope:good_production_per_level
		#		divide = $employees_per_level$
		#		save_temporary_value_as = value_mult
		#	}
			# IF YOU USE THIS (or something like it), REACTIVATE employees_per_level INPUT IN BUILDING ai_value CALCS
			# Previously, this worked alright on small buildings, but became ineffective as buildings grow, and the profitability ai value includes bugged price change estimates for all building levels, not just the next one.
			# With the current state - this makes it hard/impossible for the AI to respond to goods shortages so the multiplier is disabled.
			
			# So, situational override:
			if = {
				limit = {
					exists = b:$building$ # Avoid this preventing the 1st level being built.
					scope:relative_after_queued > {	# Apply some threshold of sell/buy to limit it. [t = (BSD+1)*0.5] <- halfway to minimum
						value = define:NEconomy|BUY_SELL_DIFF_AT_MAX_FACTOR
						add = 1
						multiply = 0.5
					}
		#			# If BUY_SELL_DIFF_AT_MAX_FACTOR set to 4 then; if buy orders are 4x sell orders price is maxed.
		#			# The inverse is true also that if sell orders are 4x buy orders, price is minimised.
		#			# Therefore sell/buy fraction halfway between 1 and BUY_SELL_DIFF_AT_MAX_FACTOR = half way to minimum price.
		#			# Therefore t = (1+BSD)/2 (BSD=2 -> t=1.5, BSD=3 -> t=2, etc.)
		#			# Local Goods are eventually supposed supposed to be cheap, so half way to minimum price is a good cutoff.
				}
				value = 99999999999	# (Subtracted) Kill it dead, stop building stuff that's not needed.
			}
			else = {
				value = 0
			}
		}
	}
}
