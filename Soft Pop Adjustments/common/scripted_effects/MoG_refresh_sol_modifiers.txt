# Expects state scope
refresh_expected_sol_modifier = {
	#if = {
	#	limit = { this = this.owner }	# This is only needed because apparently on_monthly_pulse_state is bugged and can report a country scope.
		# I'm in country scope
	#}
	#else = {
		save_temporary_scope_as = sol_calc_target_state
		
		# any_scope_state = THIS
		
		set_local_variable = {
			name = national_weight
			value = {
				value = 0.15
				add = {
					value = 0.45
					multiply = literacy_rate
				}
			}
		}
		
		save_temporary_scope_value_as = {
			name = weighted_average_sol
			value = {
				# Mostly state average
				add = {
					value = average_sol
					multiply = {
						value = 1
						subtract = local_var:national_weight
					}
				}
				
				# a little nation average
				add = {
					value = owner.average_sol
					multiply = local_var:national_weight
				}
			}
		}
		
		save_temporary_scope_value_as = {
			name = average_expected_sol_from_literacy
			value = {
				value = owner.modifier:state_expected_sol_from_literacy
				multiply = literacy_rate
			}
		}
		
		# scale           - How much of average SOL does this strata expect
		# literacy_factor - How much impact does literacy have. Pulls expectations upwards towards the average
		scope:sol_calc_target_state = {
			refresh_strata_expected_sol_modifier = { strata = lower  scale = -10   literacy_factor = 0.5 }
			refresh_strata_expected_sol_modifier = { strata = middle scale =   0   literacy_factor = 0   }
			refresh_strata_expected_sol_modifier = { strata = upper  scale =  11.5 literacy_factor = 0   }
		}
	#}
}

refresh_strata_expected_sol_modifier = {
	if = {
		limit = { has_modifier = mog_$strata$_strata_expected_sol_from_average }
		remove_modifier = mog_$strata$_strata_expected_sol_from_average
	}
	
	save_temporary_scope_value_as = {
		name = scale
		value = {
			value = $scale$
			# Pull expectations towards average sol based on literacy
			multiply = {
				value = 1
				subtract = {
					value = $literacy_factor$
					multiply = literacy_rate
				}
			}
		}
	}
	
	save_temporary_scope_value_as = {
		name = base_expectation
		value = {
			value = owner.modifier:state_$strata$_strata_expected_sol_add
			add = scope:average_expected_sol_from_literacy
		}
	}
	
	save_temporary_scope_value_as = {
		name = scaled_average_sol
		value = {
			value = scope:weighted_average_sol
			add = scope:scale
		}
	}
	
	set_local_variable = {
		name = expectation_modifier
		value = {			
			if = { # Below base expectation, slope towards base strata expectation, rather than zero
				limit = {
					scope:scaled_average_sol < scope:base_expectation
				}
				value = owner.modifier:state_$strata$_strata_expected_sol_add
				add = {
					value = scope:weighted_average_sol
					multiply = scope:average_expected_sol_from_literacy
					divide = {
						value = owner.modifier:state_$strata$_strata_expected_sol_add
						subtract = scope:scale
						add = scope:average_expected_sol_from_literacy
					}
				}
			}
			else = {
				value = scope:scaled_average_sol
			}
			
			# If the average is not starving, the floor can be a little higher
			min = {
				value = scope:weighted_average_sol
				subtract = 5 # define:NPops|SOL_STARVING_THRESHOLD
				divide = 2
				add = owner.modifier:state_$strata$_strata_expected_sol_add
			}
			
			# Don't double count base expectations in the modifier
			# This also removes the *average* effect of expected sol from literacy
			#  - a highly literate pop surrounded by low literacy pops will have raised expectations
			#  - a low literacy pop surronded by highly litereate pops will have lowered expectations
			subtract = scope:base_expectation
		}
	}
	
	add_modifier = {
		name = mog_$strata$_strata_expected_sol_from_average
		multiplier = local_var:expectation_modifier
	}
}